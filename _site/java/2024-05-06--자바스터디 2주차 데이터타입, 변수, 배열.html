<!DOCTYPE html>
<html lang="en">


<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="description" content="2주차 : 자바 데이터 타입, 변수, 배열" />
  <link rel="canonical" href="http://localhost:4000/java/2024-05-06--%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%202%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8,%20%E1%84%87%E1%85%A7%E1%86%AB%E1%84%89%E1%85%AE,%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%A7%E1%86%AF.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="preload" href="/assets/fonts/open-sans-v17-latin-regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/assets/fonts/open-sans-v17-latin-regular.woff" as="font" type="font/woff" crossorigin="anonymous">
  <link rel="stylesheet" href="/assets/main.css"/>
  <link rel="alternate" type="application/rss+xml" title="지속하여 생각하고 고민하는" href="/feed.xml" />
  <title>백기선 자바스터디 2주차 자바 데이터 타입, 변수, 배열 &middot; 지속하여 생각하고 고민하는</title>
  
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "author": "",
        "datePublished": "2024-05-06T00:00:00+09:00",
        "headline": "백기선 자바스터디 2주차 자바 데이터 타입, 변수, 배열",
        "url": "http://localhost:4000/java/2024-05-06--%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%202%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8,%20%E1%84%87%E1%85%A7%E1%86%AB%E1%84%89%E1%85%AE,%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%A7%E1%86%AF.html",
        "inLanguage": "en-US",
        "isFamilyFriendly": "true",
        "keywords": "java",
        "image": "http://localhost:4000/favicon.ico",
        "mainEntityOfPage": {
          "@type": "WebPage",
          "@id": "http://localhost:4000/java/2024-05-06--%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%202%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8,%20%E1%84%87%E1%85%A7%E1%86%AB%E1%84%89%E1%85%AE,%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%A7%E1%86%AF.html"
       }
      }
    </script>
  
</head>

<body>
<div class="container">
  <nav class="top-nav">
  <a class="nav-item" href='/'>Home</a>
  | <a class="nav-item" href='/tags'>Tags</a>
  | <a class="nav-item" href='/about'>About</a>
  | <a class="nav-item" href="/feed.xml">RSS</a>
  | <a class="nav-item dark-light-switch" href="#"></a>
</nav>

  <hr class="stylish"/>
  <div class="_progress-wrapper">
  <div id="_progress"></div>
</div>

<header>
  <h1>백기선 자바스터디 2주차 자바 데이터 타입, 변수, 배열</h1>
  <header class="title-tags">
    <time datetime="2024-05-06T00:00:00+09:00">6 May, 2024. It was a Monday.</time>
    <div class="tags-container">
      Posted under <span>
          
            <a class="tags" href="/tags#java">java</a>
          
        </span>
      &nbsp;
    </div>
  </header>
</header>

<hr class="stylish" />

<main role="main">

  <article>

    <section class="content">
      <h1 id="2주차--자바-데이터-타입-변수-배열">2주차 : 자바 데이터 타입, 변수, 배열</h1>

<h2 id="목표">목표</h2>

<p>자바의 프리미티브 타입, 변수 그리고 배열을 사용하는 방법을 익힙니다.</p>

<h2 id="학습할-것">학습할 것</h2>

<ul>
  <li>프리미티브 타입 종류와 값의 범위 그리고 기본 값</li>
  <li>프리미티브 타입과 레퍼런스 타입</li>
  <li>리터럴</li>
  <li>변수 선언 및 초기화하는 방법</li>
  <li>변수의 스코프와 라이프타임</li>
  <li>타입 변환, 캐스팅 그리고 타입 프로모션</li>
  <li>1차 및 2차 배열 선언하기</li>
  <li>타입 추론, var</li>
</ul>

<hr />

<h2 id="1-프리미티브-타입-종류와-값의-범위-그리고-기본-값">1. <strong>프리미티브 타입 종류와 값의 범위 그리고 기본 값</strong></h2>

<h3 id="primitive-type">Primitive Type</h3>

<ul>
  <li>정수형
    <ul>
      <li>byte, short, int, long, char</li>
      <li>boolean</li>
    </ul>
  </li>
  <li>실수형
    <ul>
      <li>float, double</li>
    </ul>
  </li>
</ul>

<p>byte, short, int, long, float,double, char, boolean가 존재.</p>

<p>경우에 따라서 <strong>int, long은 unsigned와 signed로 나눠서 표기하는 경우도 존재한다.</strong></p>

<p>여기서 unsigned는 음수가 없는 양수의 값만을 의미하고, signed는 말 그대로 기호가 표기된 음수값등을 의미한다. 프리미티브 타입이 나타낼 수 잆는 값의 범위와 기본 값은 아래와 같다.</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>크기</th>
      <th>값의 범위</th>
      <th>기본 값</th>
      <th>비고</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>byte</td>
      <td>1 byte</td>
      <td>-128 ~ 127</td>
      <td>0</td>
      <td> </td>
    </tr>
    <tr>
      <td>short</td>
      <td>2 bytes</td>
      <td>32,768 ~ 32,767</td>
      <td>0</td>
      <td> </td>
    </tr>
    <tr>
      <td>int</td>
      <td>4 bytes</td>
      <td>$-2^{31}$ ~ $2^{32}-1$</td>
      <td>0</td>
      <td> </td>
    </tr>
    <tr>
      <td>long</td>
      <td>8 bytes</td>
      <td>$-2^{63}$ ~$2^{64}-1$</td>
      <td>0L</td>
      <td> </td>
    </tr>
    <tr>
      <td>float</td>
      <td>4 bytes</td>
      <td> </td>
      <td>0.0F</td>
      <td>정밀도: 7</td>
    </tr>
    <tr>
      <td>double</td>
      <td>8 bytes</td>
      <td> </td>
      <td>0.0</td>
      <td>정밀도: 15</td>
    </tr>
    <tr>
      <td>char</td>
      <td>2 bytes</td>
      <td>0 ~ 65,535</td>
      <td>\u0000</td>
      <td> </td>
    </tr>
    <tr>
      <td>boolean</td>
      <td>1 byte</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>(java가 다루는</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>최소 데이터 범위)</td>
      <td>T/F</td>
      <td>false</td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>자료형 값의 범위를 초과하는 값을 선언하면 컴파일 에러 발생</p>
</blockquote>

<h3 id="정수형과-실수형이-같은-크기의-데이터를-저장함에도-불구하고-실수형이-더-큰-값을-저장할-수-있는-이유는-무엇일까">정수형과 실수형이 같은 크기의 데이터를 저장함에도 불구하고 실수형이 더 큰 값을 저장할 수 있는 이유는 무엇일까?</h3>

<ul>
  <li>실수형은 가수, 지수를 이용하여 ‘부동소수점’ 방식으로 값을 저장하기에 값을 더 정확히 표현가능.</li>
</ul>

<h3 id="실수자료형">실수자료형</h3>

<ul>
  <li>실수형에서는 값을 부호, 지수, 가수로 나누어 저장.</li>
  <li><strong>Q1) 실수형의 정밀도?</strong></li>
  <li><strong>Q2) Unsinged란? 자바에서는 어떻게 취급하고 있으며 나누는 이유는?</strong></li>
  <li><strong>Q3) 고정 소수점 및 부동소수점 문제</strong></li>
</ul>

<h2 id="2-프리미티브-타입과-레퍼런스-타입">2. <strong>프리미티브 타입과 레퍼런스 타입</strong></h2>

<ul>
  <li>위에서 언급한 Primitive Type을 제외한 나머지가 Reference Type.</li>
  <li>Reference Type의 예
    <ul>
      <li>String<strong>(Class Type, 불변이므로)</strong>, 배열, Class, Interface, Enum(Type Variable)형으로 선언한 Objtect가 모두 다 Reference Type</li>
    </ul>
  </li>
</ul>

<h2 id="3-리터럴">3. <strong>리터럴</strong></h2>

<h3 id="리터럴의-정의란">리터럴의 정의란?</h3>

<p>즉, 고정된 값 그 자체를 의미. Primitive Type에 할당할 수 있음.</p>

<blockquote>
  <p>A <em>literal</em> is the source code representation of a fixed value; literals are represented directly in your code without requiring computation</p>
</blockquote>

<p>참고 : <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html">https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html</a></p>

<p>리터럴의 예시</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">boolean</span> <span class="n">result</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
<span class="kt">char</span> <span class="n">capitalC</span> <span class="o">=</span> <span class="sc">'C'</span><span class="o">;</span>
<span class="kt">byte</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span>
<span class="kt">short</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">10000</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">100000</span><span class="o">;</span>
</code></pre></div></div>

<ul>
  <li><strong>Q1) 참조자료형의 경우 리터럴이라고 할 수 없는가? 또 없다면 그 이유는 new 연산을 통해 생성되기 때문인가? 아니면 참조자료형 자체가 리터럴로 불릴 수 없는 것인가?</strong>
    <ul>
      <li>인스턴스 안의 값이 ‘불변성’을 보장한다면 ‘객체 리터럴’이 될 수 있음</li>
    </ul>
  </li>
  <li><strong>Q2) 리터럴과 상수는 어떻게 다르나?</strong>
    <ul>
      <li>일단 첫번째 주의점은 많은 사람들이 ‘final’ 키워드를 붙이면 ‘상수’라고 표현한다고 하지만, final의 정의는 ‘한 번만 초기화 가능하다’이다.</li>
      <li>즉, final을 붙인다고 ‘상수’가 되는 것은 아니다.</li>
      <li>상수 → 변수인데 변하지 않는 수</li>
    </ul>
  </li>
</ul>

<h2 id="4-변수-선언-및-초기화하는-방법">4. <strong>변수 선언 및 초기화하는 방법</strong></h2>

<p>변수를 선언하고 초기화 하는 것은 한 번에 작성할 수도 있지만  당연히 반드시 한 번에 이뤄줘야하는 것은 아님.</p>

<h2 id="변수-선언">변수 선언</h2>

<ul>
  <li>Primitive Type, Reference Type 모두 선언하는 것은 동일</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Primitive Type</span>
<span class="kt">int</span> <span class="n">a</span><span class="o">;</span> 

<span class="c1">// Reference Type</span>
<span class="no">A</span> <span class="n">a</span><span class="o">;</span>
</code></pre></div></div>

<h3 id="변수-초기화">변수 초기화</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Primitive Type</span>
<span class="kt">int</span> <span class="n">a</span><span class="o">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>

<span class="c1">// Reference Type</span>
<span class="no">A</span> <span class="n">a</span><span class="o">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="no">A</span><span class="o">();</span>

<span class="c1">// 명시적 초기화(선언과 동시에 초기화 하는 것, 어디서든 사용 가능)</span>
<span class="kt">long</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">200</span><span class="o">;</span> 

</code></pre></div></div>

<h2 id="5-변수의-스코프와-라이프타임">5. <strong>변수의 스코프와 라이프타임</strong></h2>

<h3 id="지역변수-클래스변수-인스턴스-변수">지역변수, 클래스변수, 인스턴스 변수</h3>

<table>
  <thead>
    <tr>
      <th>변수 종류</th>
      <th>선언 위치</th>
      <th>생성 시기 (메모리 할당)</th>
      <th>변수의 스코프</th>
      <th>기타</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>지역 변수</td>
      <td>클래스 영역 이외 (메서드, 생성자, 초기화 블록 내부 등)</td>
      <td>메서드 호출 시 (메서드가 수행될 때)</td>
      <td>해당 메서드 내</td>
      <td>블록 벗어나면 소멸</td>
    </tr>
    <tr>
      <td>클래스 변수</td>
      <td>클래스 내</td>
      <td>**클래스가 메모리에 올라갔을 때 (단 한 번 초기화) / 클래스 로더에 링킹될 때 **</td>
      <td>클래스 전역 (인스턴스 생성안하고도 사용 가능)</td>
      <td>‘Static ‘ 키워드를 변수 앞에 반드시 포함해야함.</td>
    </tr>
    <tr>
      <td>인스턴스 변수</td>
      <td>클래스 내</td>
      <td>인스턴스 생성시</td>
      <td><strong>각각의 인스턴스</strong></td>
      <td>인스턴스 별 값 상이 가능</td>
    </tr>
  </tbody>
</table>

<ul>
  <li><strong>Q) 클래스가 메모리에 올라갔다는 것의 의미는 정확히 어떤 의미이고 클래스 변수는 main보다 왜 먼저 수행되지?</strong></li>
</ul>

<h3 id="초기화-블록을-활용한-클래스-인스턴스-변수-초기화-방법"><strong>초기화 블록을 활용한 클래스, 인스턴스 변수 초기화 방법</strong></h3>

<ul>
  <li>실행 순서
    <ol>
      <li>클래스 초기화 블록 → 2. 인스턴스 초기화 블록 → 3. 생성자</li>
    </ol>
  </li>
  <li>클래스 초기화 블록
    <ul>
      <li>클래스 변수의 복잡한 초기화에 사용. 로직 추가 가능. 명시적 초기화로는 부족할 때사용</li>
      <li>클래스가 초기화 될때 실행되고, main 보다 먼저 수행</li>
    </ul>
  </li>
  <li>인스턴스 초기화 블록
    <ul>
      <li>인스턴스 변수의 복잡한 초기화에 사용.</li>
      <li>모든 생성자가 공통으로 수행해야하는 로직 수행(메서드도 작성 가능)</li>
      <li>인스턴스 생성시마다 실행(생성자와 동일함)</li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">ClassA</span><span class="o">{</span>
    <span class="kd">static</span> <span class="o">{</span> <span class="o">}</span> <span class="c1">//클래스 초기화 블럭</span>
    <span class="o">{</span>        <span class="o">}</span> <span class="c1">//인스턴스 초기화 블럭</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>CF) Primitive Type과 ReferenceType 변수에서 추가적인 다른 차이는 GC의 대상이 되느냐 여부이다.</strong></p>

<ul>
  <li><strong>CF) Static 클래스(학습 필요)</strong>
    <ul>
      <li>static 클래스
        <ul>
          <li>일반적인 클래스, 즉 top-level 클래스에 적용하면 문법 오류입니다.
            <ul>
              <li>그러나 이것이 top-level 클래스가 <code class="highlighter-rouge">static</code>하지 않다는 뜻이 아닙니다.</li>
            </ul>
          </li>
          <li>중첩 클래스(nested class)에만 사용할 수 있습니다.
            <ul>
              <li>static nested class: <code class="highlighter-rouge">static</code>으로 정의된 nested class</li>
              <li>inner class: <code class="highlighter-rouge">static</code>으로 정의되지 않은(non-static) nested class</li>
            </ul>
          </li>
          <li>부모 클래스의 멤버 필드 중에는 <code class="highlighter-rouge">static</code> 필드에만 접근할 수 있습니다.</li>
          <li>사실상 일반적인 top-level 클래스와 동일하게 동작하지만, 그 위치가 하나의 top-level 클래스 안에 들어있는 것입니다.
            <ul>
              <li>이것은 유사한 클래스 집합을 하나로 묶고, 클래스 패키징 구조를 편리하게 정리하는 테크닉으로 사용될 수 있습니다.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="6-타입-변환-캐스팅-그리고-타입-프로모션">6. <strong>타입 변환, 캐스팅 그리고 타입 프로모션</strong></h2>

<h3 id="타입-변환이-필요한-이유">타입 변환이 필요한 이유?</h3>

<ul>
  <li>연산을 위해 다른 타입 일치를 위해 수행.</li>
</ul>

<h3 id="primitive-type-1">Primitive Type</h3>

<ul>
  <li>
    <p>타입 프로모션</p>

    <ul>
      <li>작은 자료형 → 큰 자료형</li>
      <li>컴파일러가 <strong>‘자동 형변환’</strong> 수행</li>
      <li>ex) int → long, byte → int</li>
    </ul>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">20</span><span class="o">;</span> 
<span class="kt">long</span> <span class="n">b</span><span class="o">=</span> <span class="n">a</span><span class="o">;</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>타입 캐스팅</p>

    <ul>
      <li>큰 자료형 → 작은 자료형</li>
      <li>타입캐스팅을 해주지 않으면 타입 프로모션과 달리 컴파일 에러 발생</li>
      <li>타입 캐스팅 시, 작은 데이터 타입의 표현 범위를 벗어나면 값 오류 가능. → <strong>‘오버 플로우’</strong></li>
    </ul>

    <p><img width="1000" alt="Untitled" src="https://github.com/daewon-ko/daewon-ko.github.io/assets/105340285/3406e1f6-bd18-4174-89e0-220f7672daef" /></p>

    <ul>
      <li>ex) long → int, int → byte</li>
    </ul>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 타입 캐스팅을 해주지 않으면 컴파일 에러 발생</span>
<span class="kt">short</span> <span class="n">a</span><span class="o">=</span> <span class="mi">7410</span><span class="o">;</span>
<span class="kt">byte</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span> 
  
<span class="c1">// 타입 캐스팅 &amp; 값 오류 발생.</span>
<span class="kt">short</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">7410</span><span class="o">;</span>
<span class="kt">byte</span> <span class="n">b</span> <span class="o">=</span> <span class="o">(</span><span class="kt">byte</span><span class="o">)</span><span class="n">a</span><span class="o">;</span>
  
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="reference-type">Reference Type</h3>

<ul>
  <li>상속 관계에서만 타입변환 가능</li>
  <li>UpCasting
    <ul>
      <li></li>
    </ul>
  </li>
  <li>DownCasting</li>
  <li>InstanceOf</li>
</ul>

<h2 id="7-1차-및-2차-배열-선언하기">7. <strong>1차 및 2차 배열 선언하기</strong></h2>

<h3 id="배열-선언">배열 선언</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span> <span class="o">[</span><span class="n">n</span><span class="o">];</span>

<span class="kt">int</span> <span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">...};</span>

<span class="kt">int</span> <span class="o">[]</span> <span class="n">array</span> 
</code></pre></div></div>

<h3 id="1차원-배열">1차원 배열</h3>

<h3 id="2차원-배열">2차원 배열</h3>

<h3 id="배열의-메모리-구조">배열의 메모리 구조</h3>

<ul>
  <li>
    <p>1차원 배열</p>

    <ul>
      <li>RunTime Stack 영역에 힙 영역의 주소 값을 가짐</li>
      <li><strong>(← 배열도 객체로 취급되기 때문일까?)</strong></li>
      <li>Heap 영역에 해당 자료형 크기의 요소를 갯수만큼 할당하여 저장</li>
      <li>/Users/daewon/Study/Lecture/Java_Study(백기선님)/[자바스터디] 2주차 데이터 타입, 변수, 배열/img</li>
    </ul>

    <p><img src="https://github.com/daewon-ko/daewon-ko.github.io/assets/105340285/e71bb033-75d3-4ac3-b9fc-26133b74f837" alt="Untitled 1" /></p>
  </li>
  <li>
    <p>2차원 배열</p>

    <ul>
      <li>1차원 배열과 동일하지만, 2차원 배열의 경우 Heap영역에서도 해당 메모리의 주소값을 갖고 있음</li>
    </ul>

    <p><img src="https://github.com/daewon-ko/daewon-ko.github.io/assets/105340285/91c14f15-2b65-4b43-9354-69c7987fbef7" alt="Untitled 2" /></p>
  </li>
</ul>

<p>그림 참고 : <a href="https://www.notion.so/2-38b5d67c7f5a48238529bb8f1617ea0d?pvs=21">https://www.notion.so/2-38b5d67c7f5a48238529bb8f1617ea0d</a></p>

<h2 id="8-타입-추론-var">8. <strong>타입 추론, var</strong></h2>

<h3 id="타입-추론">타입 추론</h3>

<h3 id="타입-추론과-generic-method">타입 추론과 Generic Method</h3>

<h3 id="타입-추론과-type-erasure">타입 추론과 Type-Erasure</h3>

<h3 id="var">Var</h3>

<ul>
  <li>
    <p>Java 10부터 추가</p>
  </li>
  <li>
    <p>코드 작성 시에는 타입이 확실하지 않지만, 컴파일러가 타입을 유추.</p>
  </li>
  <li>
    <p>지역변수로 사용해야하고 선언과 동시에 초기화 필요</p>
  </li>
  <li>
    <p>Var를 안 쓰는 이유?</p>

    <ul>
      <li>매개변수로 오거나 하면 무엇이 올 지 알 수 없다.</li>
    </ul>
  </li>
  <li>
    <p><strong>Q)Var는 왜 지역변수로 사용해야할까?</strong></p>

    <ul>
      <li>Var Type은 메서드의 매개변수로 사용불가</li>
    </ul>
  </li>
</ul>

<hr />

<hr />

<p>참고</p>

<p><a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html">https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html</a></p>

<p><a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variablesummary.html">https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variablesummary.html</a></p>

<p><a href="https://catsbi.oopy.io/6541026f-1e19-4117-8fef-aea145e4fc1b">https://catsbi.oopy.io/6541026f-1e19-4117-8fef-aea145e4fc1b</a></p>

<p><a href="https://www.notion.so/2-38b5d67c7f5a48238529bb8f1617ea0d?pvs=21">https://www.notion.so/2-38b5d67c7f5a48238529bb8f1617ea0d</a></p>

<p><a href="https://djkeh.github.io/articles/Why-should-final-member-variables-be-conventionally-static-in-Java-kor/">https://djkeh.github.io/articles/Why-should-final-member-variables-be-conventionally-static-in-Java-kor/</a></p>

<h3 id="2주차-스터디-토론내용">2주차 스터디 토론내용</h3>

<h3 id="정밀도">정밀도</h3>

<p>가수 부분에 1비트 더해서 10진수로 변환했을 때 크기가 10진수의 n승 안에 들어오면 정밀도이다.</p>

<p>가수부분이 정규화를 통하면 24</p>

<p>float → 정밀도 7</p>

<p>double → 정밀도 10</p>

<h3 id="symbolic-상수">Symbolic 상수</h3>

<ul>
  <li>심볼릭 상수( final 키워드를 붙인 것)</li>
  <li>심볼릭 상수 + Literal → 합해서 ‘상수’</li>
</ul>

<p><a href="https://www.geeksforgeeks.org/java-symbolic-constants/">Java - symbolic constants - GeeksforGeeks</a></p>

<p><a href="https://www.codelatte.io/courses/java_programming_basic/UJDBHCTJ8S7MZV40">[자바 무료 강의] 상수는 닫힌 상자이다</a></p>

<h3 id="상수-풀">상수 풀</h3>

<ul>
  <li>리터럴은 메모리에 올라갈 때, MetaData에 올라감</li>
  <li>같은 값을 효율적으로 관리하기 위해 자바는</li>
  <li>메모리에 위치한 특정 장소에 저장한다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 아래는 모두 동일한 상수풀에 저장</span>
<span class="kt">int</span> <span class="n">decVal</span> <span class="o">=</span> <span class="mi">26</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">hexVal</span> <span class="o">=</span> <span class="mh">0x1a</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">binVal</span> <span class="o">=</span> <span class="mb">0b11010</span><span class="o">;</span>
</code></pre></div></div>

    </section>

    <hr class="stylish"/>


    <section class="pagination">
      
      <a class="prev" href="/java/2024-05-06--HelloWorld.html">&laquo; OS의 구조</a>
      
      
    </section>

  </article>

</main>

</div>
<footer>
  <hr class="stylish"/>
  <nav class="top-nav">
  <a class="nav-item" href='/'>Home</a>
  | <a class="nav-item" href='/tags'>Tags</a>
  | <a class="nav-item" href='/about'>About</a>
  | <a class="nav-item" href="/feed.xml">RSS</a>
  | <a class="nav-item dark-light-switch" href="#"></a>
</nav>

  <div>
    Theme: <a href="https://github.com/abhn/Elementary">Elementary</a>
    <br/>
    <a>지속하여 생각하고 고민하는</a> &copy; 2024
  </div>
</footer>

  <script src="/assets/main.js"></script>

</body>
</html>
